# Outline for Q learning player
import numpy as np
import random
import collections


# Just as a heads up, I wrote documentation for the more complex functions, but lots I ignored
class QLearningAgent():

    """
    A Q-learning agent for a board game.

    Attributes
    ----------
    name : str
        The name of the player.
    color : str
        The color representing the player.
    isAI : bool
        Indicates if the player is an AI.
    q_table : collections.defaultdict
        The Q-table used for storing state-action values.
    learning_rate : float
        The learning rate for Q-learning updates.
    discount_factor : float
        The discount factor for future rewards.
    exploration_rate : float
        The exploration rate for choosing random actions.
    """

    def __init__(self, playerName, playerColor, learning_rate=0.1, discount_factor=0.9, exploration_rate=0.1):
        """
        Initialize the QLearningAgent.

        Parameters
        ----------
        playerName : str
            The name of the player.
        playerColor : str
            The color representing the player.
        learning_rate : float, optional
            The learning rate for Q-learning updates (default is 0.1).
        discount_factor : float, optional
            The discount factor for future rewards (default is 0.9).
        exploration_rate : float, optional
            The exploration rate for choosing random actions (default is 0.1).
        """
        
        # General parameters
        self.name = playerName
        self.color = playerColor
        self.isAI = True

        # Q-learning specific parameters
        self.q_table = collections.defaultdict(lambda: np.zeros(self.action_space_size()))
        self.learning_rate = learning_rate
        self.discount_factor = discount_factor
        self.exploration_rate = exploration_rate

    def game_setup(self):
        """
        Set up the initial state of the game for the agent.
        """
        self.victoryPoints = 0
        self.settlementsLeft = 5
        self.roadsLeft = 15
        self.citiesLeft = 4
        self.resources = {'ORE':0, 'BRICK':4, 'WHEAT':2, 'WOOD':4, 'SHEEP':2} 

        self.knightsPlayed = 0
        self.largestArmyFlag = False

        self.maxRoadLength = 0
        self.longestRoadFlag = False

        self.buildGraph = {'ROADS':[], 'SETTLEMENTS':[], 'CITIES':[]}
        self.portList = []

        self.newDevCards = []
        self.devCards = {'KNIGHT':0, 'VP':0, 'MONOPOLY':0, 'ROADBUILDER':0, 'YEAROFPLENTY':0}
        self.devCardPlayedThisTurn = False

        self.visibleVictoryPoints = self.victoryPoints - self.devCards['VP']


    def get_possible_actions(self):
        """
        Get the possible actions the agent can take based on current resources.

        Returns
        -------
        list
            A list of possible actions the agent can take including locations.
        """

        possible_actions = []

        required_resources = {'WOOD': 1, 'BRICK': 1, 'WHEAT': 1, 'SHEEP': 1}
        if all(self.resources[res] >= amount for res, amount in required_resources.items()):
            possible_locations = self.get_possible_settlement_locations()
            if possible_locations:
                possible_actions.append(('build_settlement', possible_locations))

        city_resources = {'ORE': 3, 'WHEAT': 2}
        if all(self.resources[res] >= amount for res, amount in city_resources.items()):
            possible_locations = self.get_possible_city_locations()
            if possible_locations:
                possible_actions.append(('build_city', possible_locations))

        road_resources = {'WOOD': 1, 'BRICK': 1}
        if all(self.resources[res] >= amount for res, amount in road_resources.items()):
            possible_locations = self.get_possible_road_locations()
            if possible_locations:
                possible_actions.append(('build_road', possible_locations))

        development_card_resources = {'ORE': 1, 'WHEAT': 1, 'SHEEP': 1}
        if all(self.resources[res] >= amount for res, amount in development_card_resources.items()):
            possible_actions.append('buy_development_card')
        
        return possible_actions
    
    def get_possible_settlement_locations(self):
        possible_locations = []

        return possible_locations

    def get_possible_city_locations(self):
        possible_locations = []

        return possible_locations
    
    def get_possible_road_locations(self):
        possible_locations = []

        return possible_locations

    def get_state(self):
        # Seems pretty self explanatory
        return (
            self.settlementsLeft,
            self.roadsLeft,
            self.citiesLeft,
            tuple(self.resources.values()),
            self.knightsPlayed,
            self.maxRoadLength,
            self.victoryPoints,
            self.longestRoadFlag,
            self.largestArmyFlag
        )

    def get_reward(self):
        # This seems like an okay way to start but maybe want to add more rewards
        return self.victoryPoints

    def get_best_action(self, state):
        """
        Get the best action for the given state based on the Q-table.

        Parameters
        ----------
        state : tuple
            The current state of the agent.

        Returns
        -------
        str or None
            The best action for the given state, or None if no actions are possible.
        """
        possible_actions = self.get_possible_actions()
        if not possible_actions:
            return None
        return max(possible_actions, key=lambda action: self.q_table[state][action])
    
    def choose_action(self, state):
        if np.random.rand() < self.epsilon:
            return random.choice(self.get_possible_actions(state))
        else:
            return self.get_best_action(state)

    def update_q_table(self, state, action, reward, next_state):
        best_next_action = np.argmax(self.q_table[next_state])
        td_target = reward + self.discount_factor * self.q_table[next_state][best_next_action]
        td_error = td_target - self.q_table[state][action]
        self.q_table[state][action] += self.learning_rate * td_error


    def move(self, board):
        state = self.get_state(board)
        action = self.choose_action(state)
        self.execute_action(action, board)
        next_state = self.get_state(board)
        reward = self.get_reward(board)
        self.update_q_table(state, action, reward, next_state)

    # 
    def execute_action(self, action, board):
        if action == 'build_settlement':
            pass
        elif action == 'build_city':
            pass
        elif action == 'build_road':
            pass
        elif action == 'trade':
            pass
        elif action == 'draw_dev_card':
            self.draw_devCard(board)
        elif action == 'play_dev_card':
            pass
        elif action == 'end_turn':
            pass


    def build_settlement(self, vCoord, board):
        if self.resources['BRICK'] > 0 and self.resources['WOOD'] > 0 and self.resources['SHEEP'] > 0 and self.resources['WHEAT'] > 0:
            if self.settlementsLeft > 0:
                self.buildGraph['SETTLEMENTS'].append(vCoord)
                self.settlementsLeft -= 1
                self.resources['BRICK'] -= 1
                self.resources['WOOD'] -= 1
                self.resources['SHEEP'] -= 1
                self.resources['WHEAT'] -= 1
                self.victoryPoints += 1
                board.updateBoardGraph_settlement(vCoord, self)

        
    def build_city(self, vCoord, board):
        if self.resources['WHEAT'] >= 2 and self.resources['ORE'] >= 3:
            if self.citiesLeft > 0:
                self.buildGraph['CITIES'].append(vCoord)
                self.settlementsLeft += 1
                self.citiesLeft -=1
                self.resources['ORE'] -= 3
                self.resources['WHEAT'] -= 2
                self.victoryPoints += 1
                board.updateBoardGraph_city(vCoord, self)

    def build_road(self, v1, v2, board):
        if self.resources['BRICK'] > 0 and self.resources['WOOD'] > 0:
            if self.roadsLeft > 0:
                self.buildGraph['ROADS'].append((v1, v2))
                self.roadsLeft -= 1
                self.resources['BRICK'] -= 1
                self.resources['WOOD'] -= 1
                board.updateBoardGraph_road(v1, v2, self)
                maxRoads = self.get_road_length(board)
                self.maxRoadLength = maxRoads

    def draw_devCard(self, board):
        if self.resources['WHEAT'] >= 1 and self.resources['ORE'] >= 1 and self.resources['SHEEP'] >= 1:
            devCardsToDraw = []
            for cardName, cardAmount in board.devCardStack.items():
                devCardsToDraw += [cardName] * cardAmount
            if devCardsToDraw == []:
                return
            devCardIndex = np.random.randint(0, len(devCardsToDraw))
            devCardsToDraw = np.random.permutation(devCardsToDraw)
            cardDrawn = devCardsToDraw[devCardIndex]
            self.resources['ORE'] -= 1
            self.resources['WHEAT'] -= 1
            self.resources['SHEEP'] -= 1
            if cardDrawn == 'VP':
                self.victoryPoints += 1
                board.devCardStack[cardDrawn] -= 1
                self.devCards[cardDrawn] += 1
                self.visibleVictoryPoints = self.victoryPoints - self.devCards['VP']
            else:
                self.newDevCards.append(cardDrawn)
                board.devCardStack[cardDrawn] -= 1

    def trade_with_bank(self, resources):
        r1, r2 = resources
        r1_port = "2:1 " + r1
        if r1_port in self.portList and self.resources[r1] >= 2:
            self.resources[r1] -= 2
            self.resources[r2] += 1
        elif '3:1 PORT' in self.portList and self.resources[r1] >= 3:
            self.resources[r1] -= 3
            self.resources[r2] += 1
        elif self.resources[r1] >= 4:
            self.resources[r1] -= 4
            self.resources[r2] += 1
    
    def move_robber(self, hexIndex, board, player_robbed):
        board.updateBoardGraph_robber(hexIndex)
        self.steal_resource(player_robbed)
        return
    
    def get_road_length(self, board):
        roadLengths = [] #List to store road lengths from each starting edge
        for road in self.buildGraph['ROADS']: #check for every starting edge
            self.road_i_lengths = [] #List to keep track of all lengths of roads resulting from this root road
            roadCount = 0
            roadArr = []
            vertexList = []
            #print("Start road:", road)
            self.check_path_length(road, roadArr, roadCount, vertexList, board.boardGraph)

            road_inverted = (road[1], road[0])
            roadCount = 0
            roadArr = []
            vertexList = []
            self.check_path_length(road_inverted, roadArr, roadCount, vertexList, board.boardGraph)
                
            roadLengths.append(max(self.road_i_lengths)) #Update roadLength with max starting from this road
            #print(self.road_i_lengths)

        #print("Road Lengths:", roadLengths, max(roadLengths))
        return max(roadLengths)
    
    def check_path_length(self, edge, edgeList, roadLength, vertexList, boardGraph):
        #Append current edge to list and increment road count
        edgeList.append(edge) #Append the road
        roadLength += 1
        vertexList.append(edge[0]) #Append the first vertex
        
        #Get new neighboring forward edges from this edge - not visited by the search yet
        road_neighbors_list = self.get_neighboring_roads(edge, boardGraph, edgeList, vertexList)
        
        #print(neighboringRoads)
        #if no neighboring roads exist append the roadLength upto this edge
        if(road_neighbors_list == []):
            #print("No new neighbors found")
            self.road_i_lengths.append(roadLength)
            return

        else:
            #check paths from left and right neighbors separately
            for neighbor_road in road_neighbors_list:
                #print("checking neighboring edge:", neighbor_road)
                self.check_path_length(neighbor_road, edgeList, roadLength, vertexList, boardGraph)

    def get_neighboring_roads(self, road_i, boardGraph, visitedRoads, visitedVertices):
        #print("Getting neighboring roads for current road:", road_i)
        newNeighbors = []
        #Use v1 and v2 to get the vertices to expand from
        v1 = road_i[0]
        v2 = road_i[1] 
        for edge in self.buildGraph['ROADS']:
            if(edge[1] in visitedVertices):
                edge = (edge[1], edge[0]) #flip the edge if the orientation is reversed

            if(edge not in visitedRoads): #If it is a new distinct edge
                if(boardGraph[v2].state['Player'] in [self, None]):#Add condition for vertex to be not colonised by anyone else
                    if(edge[0] == v2 and edge[0] not in visitedVertices):  #If v2 has neighbors, defined starting or finishing at v2
                        #print("Appending NEW neighbor:", edge)
                        newNeighbors.append(edge)

                    if(edge[0] == v1 and edge[0] not in visitedVertices):
                        newNeighbors.append(edge)

                    if(edge[1] == v2 and edge[1] not in visitedVertices): #If v1 has neighbors, defined starting or finishing at v2
                        newNeighbors.append((edge[1], edge[0]))

                    if(edge[1] == v1 and edge[1] not in visitedVertices):
                        newNeighbors.append((edge[1], edge[0]))

        return newNeighbors
    
    def end_turn():
        'Pass turn to next player and update game state'

    def updateDevCards(self):
        for newCard in self.newDevCards:
            self.devCards[newCard] += 1

        #Reset the new card list to blank
        self.newDevCards = []

    